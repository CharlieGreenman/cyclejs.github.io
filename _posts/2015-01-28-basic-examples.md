---
title:  "Basic examples"
tags: chapters
---

Cycle.js apps will always include at least three important components: `main()`, drivers, and `run()`. In `main()`, we listen to drivers (the input to `main`), and we speak to drivers (the output of `main`). In Haskell 1.0 jargon, `main()` takes driver "*response*" Observables and output driver "*request*" Observables. `Cycle.run()` ties `main()` and drivers together, as we saw in the last chapter.

{% highlight js %}
function main(driverResponses) {
  let driverRequests = {
    DOM: // transform driverResponses.DOM
         // through a series of RxJS operators
  };
  return driverRequests;
}

let drivers = {
  DOM: makeDOMDriver('#app')
};

Cycle.run(main, drivers);
{% endhighlight %}

In the case of the DOM Driver, our `main()` will interact with the user through the DOM. Most of our examples will use the DOM Driver, but keep in mind Cycle.js is modular and extensible. You could build an application, targetting native mobile for instance, without using the DOM Driver.

<h2 id="toggle-a-checkbox">Toggle a checkbox</h2>

Let's start from the assumption we have an `index.html` file with an element to contain our app.

{% highlight html %}
<!DOCTYPE html>
<html>
  <head>
    <script src="./checkbox-app.js"></script>
    <meta charset="utf-8">
    <title>Cycle.js checkbox</title>
  </head>
  <body>
    <div id="app"></div> <!-- Our container -->
  </body>
</html>
{% endhighlight %}

We will point our Cycle.js app to live inside `#app`. The `checkbox-app.js` file should look like this (before it is transpiled from ES6 to ES5, if that is required):

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main(responses) {
  let requests = {DOM: null};
  return requests;
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

Cycle *Web* is a package containing two drivers and some helpers to use those libraries. A DOM Driver is created with `makeDOMDriver()` and an HTML Driver (for server-side rendering) is created with `makeHTMLDriver()`. `CycleWeb` also includes `h()` and `svg()`, these are functions that output [`virtual-dom`](https://github.com/Matt-Esch/virtual-dom) virtual elements, usually called *VTree*.

Our `main()` for now does nothing. It takes driver `responses` and outputs driver `requests`. To make something appear on the screen, we need to output an Observable of VTree in `requests.DOM`. The name `DOM` in `requests` must match the name we gave in the drivers object given to `Cycle.run()`. This is how Cycle.js knows which drivers to match with which request Observables. This is also true for responses: we listen to DOM events by using `responses.DOM`.

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main(responses) {
  let requests = {
    DOM: Cycle.Rx.Observable.just(false)
      .map(toggled =>
        h('div', [
          h('input', {type: 'checkbox'}), 'Toggle me',
          h('p', toggled ? 'ON' : 'off')
        ])
      )
  };
  return requests;
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/yusope/embed?output">JS Bin on jsbin.com</a>

We just added an Observable of a `false` mapped to a VTree. [`Observable.just(x)`](http://reactivex.io/documentation/operators/just.html) creates a simple Observable which simply emits `x` once, then we used [`map()`](http://reactivex.io/documentation/operators/map.html) to convert that to the `virtual-dom` VTree containing an `<input type="checkbox">` and a `<p>` element displaying `off` if the `toggled` boolean was `false`, and displaying `ON` otherwise.

This is nice: we can see the DOM elements generated by the `virtual-dom` elements created with `h()`. But if we click the "Toggle me" checkbox, the label "off" under it does not change to "ON". That is because we are not listening to DOM events. In essence, our `main()` isn't listening to the *user*. We do that by using `responses.DOM`:

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main(responses) {
  let requests = {
    DOM: responses.DOM.get('input', 'change') // NEW!
      .map(ev => ev.target.checked) // NEW!
      .startWith(false) // NEW!
      .map(toggled =>
        h('div', [
          h('input', {type: 'checkbox'}), 'Toggle me',
          h('p', toggled ? 'ON' : 'off')
        ])
      )
  };
  return requests;
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/qomenu/embed?output">JS Bin on jsbin.com</a>

Notice the lines we changed, with `NEW!`. We now map `change` events on the checkbox to the `checked` value of the element (the first `map()`) to VTrees displaying that value. However, we need a [`.startWith()`](http://reactivex.io/documentation/operators/startwith.html) to give a default value to be converted to a VTree. Without this, nothing would be shown! Why? Because our `requests` is reacting to `responses`, but `responses` is reacting to `requests`. If no one triggers the first event, nothing will happen. It is the same effect as meeting a stranger, and not having anything to say. Someone needs to take the initiative to start the conversation. That is what `main()` is doing: kickstarting the interaction, and then letting subsequent actions be mutual reactions between `main()` and the DOM Driver.

<h2 id="Displaying data from HTTP requests">Displaying data from HTTP requests</h2>

One of the most obvious requirements web apps normally have is to fetch some data from the server and display that. How would we build that with Cycle.js?

- What we want to achieve: post the JSBin.
- Suppose we have a backend with a database of 10 users. We want to have a frontend with one button "get a random user", and display the user's details, like name and email.
- Essentially we just need to make a request for the endpoint `/user/:number` whenever the button is clicked
- Recall the dialogue abstraction
- For instance we just mentioned it in the previous example
- Our app generated VTree Observables as "requests to the DOM"
- But out app should also be able to generate different kinds of requests
- HTTP requests are the most typical type of request
- They aren't anyhow related to the DOM, so we need a different driver for that
- HTTP Driver. It is driver like the DOM Driver: it expects a request Observable, and gives you a response Observable
- If requests are sent when clicks on the button happen, then the HTTP request Observable should depend directly on the button click Observable
- Show that code
- We give this request$ to the HTTP driver
- We need to display data for the current user, and this comes only when we get a response.
- For that purpose we need the Observable of user data to depend directly on the HTTP response Observable
- This is available from the main's input: responses.HTTP (HTTP needs to match the driver name you gave for the HTTP driver)
- `responses.HTTP` is an Observable of all the network responses this app is observing
- Because this could potentially include responses unrelated to the user, we need to filter. And we also mergeAll(), to flatten the Observable of Observables. This might feel like magic right now, so read the http driver docs if you're curious.
- We map res=>res.body to get the JSON data from the response and ignore other fields like status.
- What we display to the DOM is what we have from the current user's data in user$.
- So vtree$ depends directly on user$
- However, initially, there won't be any user$ event, because those only happen when the user clicks.
- This is the same "conversation initiative" problem we saw in the previous *checkbox* example
- So we make user$ start with a null user, and in case vtree$ sees a null user, it renders just the button
- Unless, if we have real user data, we display the name, the email, and the website
- We give vtree$ to the DOM Driver, and it renders those for us, all done.
- Show the full code
- Show the JSBin

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';
import {makeHTTPDriver} from '@cycle/http';

function main(responses) {
  const USERS_URL = 'http://jsonplaceholder.typicode.com/users/';
  let getRandomUser$ = responses.DOM.get('.get-random', 'click')
    .map(() => {
      let randomNum = Math.round(Math.random()*9)+1;
      return {
        url: USERS_URL + String(randomNum),
        method: 'GET'
      };
    });
  
  let user$ = responses.HTTP
    .filter(res$ => res$.request.url.indexOf(USERS_URL) === 0)
    .mergeAll()
    .map(res => res.body)
    .startWith(null);
  
  let vtree$ = user$.map(user =>
    h('div.users', [
      h('button.get-random', 'Get random user'),
      user === null ? null : h('div.user-details', [
        h('h1.user-name', user.name),
        h('h4.user-email', user.email),
        h('a.user-website', {href: user.website}, user.website)
      ])       
    ])
  );
  
  return {
    DOM: vtree$,
    HTTP: getRandomUser$
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app'),
  HTTP: makeHTTPDriver()
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/yizisa/embed?output">JS Bin on jsbin.com</a>

<h2 id="increment-and-decrement-a-counter">Increment and decrement a counter</h2>

We saw how to use the *dialogue* pattern of building user interfaces, but our case didn't have state: the label just reacted to the checkbox event. Normally applications have state in memory, so let's see how to build a Cycle.js app for that case.

If we have a counter Observable (emitting events to tell the current counter value), displaying the counter is as simple as this:

{% highlight js %}
count$.map(count =>
  h('div', [
    h('button.increment', 'Increment'),
    h('button.decrement', 'Decrement'),
    h('p', 'Counter: ' + count)
  ])
)
{% endhighlight %}

> <h4 id="what-does-the-suffixed-dollar-sign-mean">What does the suffixed dollar sign `$` mean?</h4>
>
> Notice we used the name `count$` for the Observable of current counter values. The dollar sign `$` *suffixed* to a name is a soft convention to indicate that the variable is an Observable. It is a naming helper to indicate types.
>
> Suppose you have an Observable of VTree depending on an Observable of "name" string
> {% highlight js %} let vtree$ = name$.map(name => h('h1', name)); {% endhighlight %}
>
> Notice that the function inside `map` takes `name` as argument, while the Observable is named `name$`. The naming convention indicates that `name` is the value being emitted by `name$`. In general, `foobar$` emits `foobar`. Without this convention, if `name$` would be named simply `name`, it would confuse readers about the types involved. Also, `name$` is succinct compared to alternatives like `nameObservable`, `nameStream`, or `nameObs`. This convention can also be extended to arrays: use plurality to indicate the type is an array. Example: `vtrees` is an array of `vtree`, but `vtree$` is an Observable of `vtree`.

But how to create `count$`? Clearly it must depend on increment clicks and decrement clicks. The former should mean a "+1" operation, and the latter a "-1" operation.

{% highlight js %}
let action$ = Cycle.Rx.Observable.merge(
  DOM.get('.decrement', 'click').map(ev => -1),
  DOM.get('.increment', 'click').map(ev => +1)
);
{% endhighlight %}

The [`merge`](http://reactivex.io/documentation/operators/merge.html) operator allows us to get an event stream of actions, either increment or decrement actions. In this sense, `merge` has *OR* semantics. But this still isn't `count$`, it is just `action$`.

`count$` should begin with zero, which justifies the use of a `startWith(0)` operator, but besides that we need a [`scan()`](http://reactivex.io/documentation/operators/scan.html) as well:

{% highlight js %}
let count$ = action$.startWith(0).scan((x,y) => x+y);
{% endhighlight %}

What does `scan` do? It is similar to [`reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) for Array, allowing us to accumulate values over the sequence. In functional programming languages, it is often called "fold". For instance, in [Elm](http://elm-lang.org/), [`foldp`](http://package.elm-lang.org/packages/elm-lang/core/2.1.0/Signal#foldp) is equivalent to `scan`. The name "*foldp*" indicates we are "folding the sequence from the *past*".

<p>
  {% include img/scan-counter.svg %}
</p>

If we put `action$` and `count$` together in our `main()`, we can implement the counter like this:

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main({DOM}) {
  let action$ = Cycle.Rx.Observable.merge(
    DOM.get('.decrement', 'click').map(ev => -1),
    DOM.get('.increment', 'click').map(ev => +1)
  );
  let count$ = action$.startWith(0).scan((x,y) => x+y);
  return {
    DOM: count$.map(count =>
        h('div', [
          h('button.decrement', 'Decrement'),
          h('button.increment', 'Increment'),
          h('p', 'Counter: ' + count)
        ])
      )
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/pefuga/embed?output">JS Bin on jsbin.com</a>

<h2 id="body-mass-index-calculator">Body mass index calculator</h2>

Now that we got the hang of Cycle.js apps with state, let's tackle something a bit larger. Consider the following [BMI](https://en.wikipedia.org/wiki/Body_mass_index) calculator: it has a slider to select the weight, a slider to select the height, and a text indicates the calculated BMI from those weight and height values selected.

<a class="jsbin-embed" href="http://jsbin.com/vikaga/embed?output">JS Bin on jsbin.com</a>

In the previous example, we had the actions *decrement* and *increment*. In this example, we have "change weight" and "change height". These seem straightforward to implement.

{% highlight js %}
let changeWeight$ = DOM.get('#weight', 'input')
  .map(ev => ev.target.value);
let changeHeight$ = DOM.get('#height', 'input')
  .map(ev => ev.target.value);
{% endhighlight %}

To combine these two actions and use their values to compute the BMI, we use the RxJS [`combineLatest`](http://reactivex.io/documentation/operators/combinelatest.html) operator. We saw in the previous example that `merge` had *OR* semantics. `combineLatest` has, on the other hand, *AND* semantics. For instance, to compute the BMI, we need a `weight` value *and* and a `height` value.

{% highlight js %}
let bmi$ = Cycle.Rx.Observable.combineLatest(
  changeWeight$.startWith(70),
  changeHeight$.startWith(170),
  (weight, height) => {
    let heightMeters = height * 0.01;
    return weight / (heightMeters * heightMeters);
  }
);
{% endhighlight %}

Now we just need a function to visualize the BMI result and the sliders. We do that by mapping `bmi$` to an Observable of VTree, and giving that to the `DOM` driver.

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main({DOM}) {
  let changeWeight$ = DOM.get('#weight', 'input')
    .map(ev => ev.target.value);
  let changeHeight$ = DOM.get('#height', 'input')
    .map(ev => ev.target.value);
  let bmi$ = Cycle.Rx.Observable.combineLatest(
    changeWeight$.startWith(70),
    changeHeight$.startWith(170),
    (weight, height) => {
      let heightMeters = height * 0.01;
      return Math.round(weight / (heightMeters * heightMeters));
    }
  );

  return {
    DOM: bmi$.map(bmi =>
      h('div', [
        h('div', [
          'Weight ___kg',
          h('input#weight', {type: 'range', min: 40, max: 140})
        ]),
        h('div', [
          'Height ___cm',
          h('input#height', {type: 'range', min: 140, max: 210})
        ]),
        h('h2', 'BMI is ' + bmi)
      ])
    )
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/subiru/embed?output">JS Bin on jsbin.com</a>

This code works, we can get the calculated BMI when we move the slider. However, if you have noticed, the labels for weight and height do not show what the slider is selecting. Instead, they just show e.g. `Weight ___kg`, which is useless since we do not know what value we are choosing for the weight.

The problem happens because when we map on `bmi$`, we do not have anymore the `weight` and `height` values. Therefore, for the function which renders the VTree, we need to use an Observable which emits a complete amount of data instead of just BMI data. We need a `state$` Observable.

{% highlight js %}
let state$ = Cycle.Rx.Observable.combineLatest(
  changeWeight$.startWith(70),
  changeHeight$.startWith(170),
  (weight, height) => {
    let heightMeters = height * 0.01;
    let bmi = Math.round(weight / (heightMeters * heightMeters));
    return {weight, height, bmi};
  }
);
{% endhighlight %}

Below is the program that uses `state$` to render all dynamic values correctly to the DOM.

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main({DOM}) {
  let changeWeight$ = DOM.get('#weight', 'input')
    .map(ev => ev.target.value);
  let changeHeight$ = DOM.get('#height', 'input')
    .map(ev => ev.target.value);
  let state$ = Cycle.Rx.Observable.combineLatest(
    changeWeight$.startWith(70),
    changeHeight$.startWith(170),
    (weight, height) => {
      let heightMeters = height * 0.01;
      let bmi = Math.round(weight / (heightMeters * heightMeters));
      return {weight, height, bmi};
    }
  );

  return {
    DOM: state$.map(({weight, height, bmi}) =>
      h('div', [
        h('div', [
          'Weight ' + weight + 'kg',
          h('input#weight', {type: 'range', min: 40, max: 140, value: weight})
        ]),
        h('div', [
          'Height ' + height + 'cm',
          h('input#height', {type: 'range', min: 140, max: 210, value: height})
        ]),
        h('h2', 'BMI is ' + bmi)
      ])
    )
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/vikaga/embed?output">JS Bin on jsbin.com</a>

Great, this program functions exactly like we want it to. Weight and height labels react to the sliders being dragged, and the BMI result gets recalculated as well.

*However*, we wrote all code inside one function: `main()`. This approach doesn't scale, and even for a small sized app like this, it already looks too large, doing too many things.

We need a proper architecture for user interfaces that follows the reactive, functional, and cyclic principles of Cycle.js. That is the subject of our [next chapter](/model-view-intent.html).

