---
title:  "Basic examples"
tags: chapters
---

**You can find the source code for these examples, and others, at [cyclejs/cycle-examples](https://github.com/cyclejs/cycle-examples).**

Cycle.js apps will always include at least three important components: `main()`, drivers, and `run()`. In `main()`, we listen to drivers (the input to `main`), and we speak to drivers (the output of `main`). In Haskell 1.0 jargon, `main()` takes driver "*response*" Observables and outputs driver "*request*" Observables. `Cycle.run()` ties `main()` and drivers together, as we saw in the last chapter.

{% highlight js %}
function main(driverResponses) {
  let driverRequests = {
    DOM: // transform driverResponses.DOM
         // through a series of RxJS operators
  };
  return driverRequests;
}

let drivers = {
  DOM: makeDOMDriver('#app')
};

Cycle.run(main, drivers);
{% endhighlight %}

In the case of the DOM Driver, our `main()` will interact with the user through the DOM. Most of our examples will use the DOM Driver, but keep in mind that Cycle.js is modular and extensible. You could build an application, targeting native mobile for instance, without using the DOM Driver.

<h2 id="toggle-a-checkbox">Toggle a checkbox</h2>

Let's start with this `index.html` file:

{% highlight html %}
<!DOCTYPE html>
<html>
  <head>
    <script src="./checkbox-app.js"></script>
    <meta charset="utf-8">
    <title>Cycle.js checkbox</title>
  </head>
  <body>
    <div id="app"></div> <!-- Our container -->
  </body>
</html>
{% endhighlight %}

We will point our Cycle.js app to live inside `#app`. The `checkbox-app.js` file should look like this (before it is transpiled from ES6 to ES5, if that is required):

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/dom';

function main(responses) {
  let requests = {DOM: null};
  return requests;
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

Cycle *DOM* is a package containing two drivers and some helpers to use those libraries. A DOM Driver is created with `makeDOMDriver()` and an HTML Driver (for server-side rendering) is created with `makeHTMLDriver()`. `CycleDOM` also includes `h()` and `svg()`. These functions output virtual elements (i.e., *VTree*). See [`virtual-dom`](https://github.com/Matt-Esch/virtual-dom) for details.

Our `main()`, for now, does nothing. It takes driver `responses` and outputs driver `requests`. To make something appear on the screen, we need to output an Observable of VTree in `requests.DOM`. The name `DOM` in `requests` must match the name we gave in the drivers object given to `Cycle.run()`. This is how Cycle.js knows which drivers to match with which request Observables. This is also true for responses: we listen to DOM events by using `responses.DOM`.

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/dom';

function main(responses) {
  let requests = {
    DOM: Cycle.Rx.Observable.just(false)
      .map(toggled =>
        h('div', [
          h('input', {type: 'checkbox'}), 'Toggle me',
          h('p', toggled ? 'ON' : 'off')
        ])
      )
  };
  return requests;
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/cusuraqago/embed?output">JS Bin on jsbin.com</a>

We just added an Observable of `false` mapped to a VTree. [`Observable.just(x)`](http://reactivex.io/documentation/operators/just.html) creates a simple Observable which simply emits `x` once. Then we use [`map()`](http://reactivex.io/documentation/operators/map.html) to convert that to the `virtual-dom` VTree containing an `<input type="checkbox">` and a `<p>` element displaying `off` if the `toggled` boolean is `false`, and displaying `ON` otherwise.

This is nice: we can see the DOM elements generated by the `virtual-dom` elements created with `h()`. But if we click the "Toggle me" checkbox, the label "off" under it does not change to "ON". That is because we are not listening to DOM events. In essence, our `main()` isn't listening to the *user*. We do that by using `responses.DOM`:

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/dom';

function main(responses) {
  let requests = {
    DOM: responses.DOM.get('input', 'change') // NEW!
      .map(ev => ev.target.checked) // NEW!
      .startWith(false) // NEW!
      .map(toggled =>
        h('div', [
          h('input', {type: 'checkbox'}), 'Toggle me',
          h('p', toggled ? 'ON' : 'off')
        ])
      )
  };
  return requests;
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/qomenu/embed?output">JS Bin on jsbin.com</a>

Notice the lines we changed (lines commented `NEW!`). We now map `change` events on the checkbox to the `checked` value of the element (the first `map()`) to VTrees displaying that value. However, we need a [`.startWith()`](http://reactivex.io/documentation/operators/startwith.html) to give a default value to be converted to a VTree. Without this, nothing would be shown! Why? Because our `requests` is reacting to `responses`, but `responses` is reacting to `requests`. If no one triggers the first event, nothing will happen. It is the same effect as meeting a stranger, and not having anything to say. Someone needs to take the initiative to start the conversation. That is what `main()` is doing: kickstarting the interaction, and then letting subsequent actions be mutual reactions between `main()` and the DOM Driver.

<h2 id="displaying-data-from-http-requests">Displaying data from HTTP requests</h2>

One of the most obvious requirements web apps normally have is to fetch and render data from the server. How would we build that with Cycle.js?

Suppose we have a backend with a database containing ten users. We want to have a front-end with one button "get a random user", and to display the user's details, like name and email. This is what we want to achieve:

<a class="jsbin-embed" href="http://jsbin.com/yizisa/embed?output">JS Bin on jsbin.com</a>

Essentially we just need to make a request for the endpoint `/user/:number` whenever the button is clicked. Where would this HTTP request fit in a Cycle.js app?

Recall the dialogue abstraction, mentioned also in the previous "checkbox" example. The app generates VTree Observables as "requests to the DOM". But our apps should also be able to generate different kinds of requests. The most typical type of request is an HTTP *request*. Since these are not in any way related to the DOM, we need a different driver to handle them.

The [HTTP Driver](https://github.com/cyclejs/cycle-http-driver) is similar in style to the DOM Driver: it expects a request Observable, and gives you a response Observable. Instead of studying the details of how the HTTP Driver works, let's see what a basic HTTP example looks like.

If HTTP requests are sent when the button is clicked, then the HTTP request Observable should depend directly on the button click Observable. Roughly, this:

{% highlight js %}
function main(responses) {
  // ...

  let click$ = responses.DOM.get('.get-random', 'click');

  const USERS_URL = 'http://jsonplaceholder.typicode.com/users/';
  // This is the HTTP request Observable
  let getRandomUser$ = click$.map(() => {
    let randomNum = Math.round(Math.random()*9)+1;
    return {
      url: USERS_URL + String(randomNum),
      method: 'GET'
    };
  });

  // ...
}
{% endhighlight %}

`getRandomUser$` is the Observable we give to the HTTP Driver, by returning it from the `main()` function:

{% highlight js %}
function main(responses) {
  // ...

  return {
    // ...
    HTTP: getRandomUser$
  };
}
{% endhighlight %}

We still need to display data for the current user, and this comes only when we get an HTTP response. For that purpose, we need the Observable of user data to depend directly on the HTTP response Observable. This is available from `main`'s input: `responses.HTTP` (the name `HTTP` needs to match the driver name you gave for the HTTP driver when calling `Cycle.run()`).

{% highlight js %}
function main(responses) {
  // ...

  let user$ = responses.HTTP
    .filter(res$ => res$.request.url.indexOf(USERS_URL) === 0)
    .mergeAll()
    .map(res => res.body);

  // ...
}
{% endhighlight %}

`responses.HTTP` is an Observable of all the network responses this app is observing. Because it could potentially include responses unrelated to user details, we need to `filter()` it. We also `mergeAll()`, to flatten the Observable of Observables. This might feel like magic right now, so read the [HTTP Driver docs](https://github.com/cyclejs/cycle-http-driver) if you're curious about the details. We map each response `res` to `res.body` in order to get the JSON data from the response and ignore other fields like HTTP status.

We still haven't specified how to render our app. We should display to the DOM whatever data we have from the current user in `user$`. So the VTree Observable `vtree$` should depend directly on `user$`, like this:

{% highlight js %}
function main(responses) {
  // ...

  let vtree$ = user$.map(user =>
    h('div.users', [
      h('button.get-random', 'Get random user'),
      h('div.user-details', [
        h('h1.user-name', user.name),
        h('h4.user-email', user.email),
        h('a.user-website', {href: user.website}, user.website)
      ])
    ])
  );

  // ...
}
{% endhighlight %}

However, initially, there won't be any `user$` event, because those only happen when the user clicks. This is the same "conversation initiative" problem we saw in the previous "checkbox" example. So we need to make `user$` start with a `null` user, and in case `vtree$` sees a null user, it renders just the button. Unless, if we have real user data, we display the name, the email, and the website:

{% highlight js %}
function main(responses) {
  // ...

  let user$ = responses.HTTP
    .filter(res$ => res$.request.url.indexOf(USERS_URL) === 0)
    .mergeAll()
    .map(res => res.body)
    .startWith(null); // NEW!

  let vtree$ = user$.map(user =>
    h('div.users', [
      h('button.get-random', 'Get random user'),
      user === null ? null : h('div.user-details', [ // NEW!
        h('h1.user-name', user.name),
        h('h4.user-email', user.email),
        h('a.user-website', {href: user.website}, user.website)
      ])
    ])
  );

  // ...
}
{% endhighlight %}

We give `vtree$` to the DOM Driver, and it renders those for us.  
When done, the whole code looks like this:

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/dom';
import {makeHTTPDriver} from '@cycle/http';

function main(responses) {
  const USERS_URL = 'http://jsonplaceholder.typicode.com/users/';
  let getRandomUser$ = responses.DOM.get('.get-random', 'click')
    .map(() => {
      let randomNum = Math.round(Math.random()*9)+1;
      return {
        url: USERS_URL + String(randomNum),
        method: 'GET'
      };
    });

  let user$ = responses.HTTP
    .filter(res$ => res$.request.url.indexOf(USERS_URL) === 0)
    .mergeAll()
    .map(res => res.body)
    .startWith(null);

  let vtree$ = user$.map(user =>
    h('div.users', [
      h('button.get-random', 'Get random user'),
      user === null ? null : h('div.user-details', [
        h('h1.user-name', user.name),
        h('h4.user-email', user.email),
        h('a.user-website', {href: user.website}, user.website)
      ])
    ])
  );

  return {
    DOM: vtree$,
    HTTP: getRandomUser$
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app'),
  HTTP: makeHTTPDriver()
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/yizisa/embed?output">JS Bin on jsbin.com</a>

<h2 id="increment-and-decrement-a-counter">Increment and decrement a counter</h2>

We saw how to use the *dialogue* pattern of building user interfaces, but our examples didn't have state: the label just reacted to the checkbox event, and the user details view just showed what came from the HTTP response. Normally applications have state in memory, so let's see how to build a Cycle.js app for that case.

If we have a counter Observable (emitting events to tell the current counter value), displaying the counter is as simple as this:

{% highlight js %}
count$.map(count =>
  h('div', [
    h('button.increment', 'Increment'),
    h('button.decrement', 'Decrement'),
    h('p', 'Counter: ' + count)
  ])
)
{% endhighlight %}

> <h4 id="what-does-the-suffixed-dollar-sign-mean">What does the suffixed dollar sign `$` mean?</h4>
>
> Notice we used the name `count$` for the Observable of current counter values. The dollar sign `$` *suffixed* to a name is a soft convention to indicate that the variable is an Observable. It is a naming helper to indicate types.
>
> Suppose you have an Observable of VTree depending on an Observable of "name" string
> {% highlight js %} let vtree$ = name$.map(name => h('h1', name)); {% endhighlight %}
>
> Notice that the function inside `map` takes `name` as an argument, while the Observable is named `name$`. The naming convention indicates that `name` is the value being emitted by `name$`. In general, `foobar$` emits `foobar`. Without this convention, if `name$` would be named simply `name`, it would confuse readers about the types involved. Also, `name$` is succinct compared to alternatives like `nameObservable`, `nameStream`, or `nameObs`. This convention can also be extended to arrays: use plurality to indicate the type is an array. Example: `vtrees` is an array of `vtree` but `vtree$` is an Observable of `vtree`.

But how do we create a `count$`? Clearly it must depend on increment clicks and decrement clicks. The former should mean a "+1" operation, and the latter a "-1" operation.

{% highlight js %}
let action$ = Cycle.Rx.Observable.merge(
  DOM.get('.decrement', 'click').map(ev => -1),
  DOM.get('.increment', 'click').map(ev => +1)
);
{% endhighlight %}

The [`merge`](http://reactivex.io/documentation/operators/merge.html) operator allows us to get an event stream of actions, either increment or decrement actions. In this sense, `merge` has *OR* semantics. But this still isn't a `count$`. It is just an `action$`.

`count$` should begin with zero, which justifies the use of a `startWith(0)` operator, but beside that, we need a [`scan()`](http://reactivex.io/documentation/operators/scan.html) as well:

{% highlight js %}
let count$ = action$.startWith(0).scan((x,y) => x+y);
{% endhighlight %}

What does `scan` do? It is similar to [`reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce), allowing us to accumulate values over the sequence. In functional programming languages, it is often called "fold". For instance, in [Elm](http://elm-lang.org/), [`foldp`](http://package.elm-lang.org/packages/elm-lang/core/2.1.0/Signal#foldp) is equivalent to `scan`. The name "*foldp*" indicates we are "folding the sequence from the *past*".

<p>
  {% include img/scan-counter.svg %}
</p>

If we put `action$` and `count$` together in our `main()`, we can implement the counter like this:

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/dom';

function main({DOM}) {
  let action$ = Cycle.Rx.Observable.merge(
    DOM.get('.decrement', 'click').map(ev => -1),
    DOM.get('.increment', 'click').map(ev => +1)
  );
  let count$ = action$.startWith(0).scan((x,y) => x+y);
  return {
    DOM: count$.map(count =>
        h('div', [
          h('button.decrement', 'Decrement'),
          h('button.increment', 'Increment'),
          h('p', 'Counter: ' + count)
        ])
      )
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/pefuga/embed?output">JS Bin on jsbin.com</a>

<h2 id="body-mass-index-calculator">Body mass index calculator</h2>

Now that we've got the hang of Cycle.js apps with state, let's tackle something a bit larger. Consider the following [BMI](https://en.wikipedia.org/wiki/Body_mass_index) calculator: it has a slider to select the weight, a slider to select the height, and the text indicates the calculated BMI from the weight and height values selected.

<a class="jsbin-embed" href="http://jsbin.com/vikaga/embed?output">JS Bin on jsbin.com</a>

In the previous example, we had the actions *decrement* and *increment*. In this example, we have "change weight" and "change height". These seem straightforward to implement.

{% highlight js %}
let changeWeight$ = DOM.get('#weight', 'input')
  .map(ev => ev.target.value);
let changeHeight$ = DOM.get('#height', 'input')
  .map(ev => ev.target.value);
{% endhighlight %}

To combine these two actions and use their values to compute the BMI, we use the RxJS [`combineLatest`](http://reactivex.io/documentation/operators/combinelatest.html) operator. We saw in the previous example that `merge` had *OR* semantics. `combineLatest` has, on the other hand, *AND* semantics. For instance, to compute the BMI, we need a `weight` value *and* and a `height` value.

{% highlight js %}
let bmi$ = Cycle.Rx.Observable.combineLatest(
  changeWeight$.startWith(70),
  changeHeight$.startWith(170),
  (weight, height) => {
    let heightMeters = height * 0.01;
    return weight / (heightMeters * heightMeters);
  }
);
{% endhighlight %}

Now we just need a function to visualize the BMI result and the sliders. We do that by mapping `bmi$` to an Observable of VTree, and giving that to the `DOM` driver.

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/dom';

function main({DOM}) {
  let changeWeight$ = DOM.get('#weight', 'input')
    .map(ev => ev.target.value);
  let changeHeight$ = DOM.get('#height', 'input')
    .map(ev => ev.target.value);
  let bmi$ = Cycle.Rx.Observable.combineLatest(
    changeWeight$.startWith(70),
    changeHeight$.startWith(170),
    (weight, height) => {
      let heightMeters = height * 0.01;
      return Math.round(weight / (heightMeters * heightMeters));
    }
  );

  return {
    DOM: bmi$.map(bmi =>
      h('div', [
        h('div', [
          'Weight ___kg',
          h('input#weight', {type: 'range', min: 40, max: 140})
        ]),
        h('div', [
          'Height ___cm',
          h('input#height', {type: 'range', min: 140, max: 210})
        ]),
        h('h2', 'BMI is ' + bmi)
      ])
    )
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/subiru/embed?output">JS Bin on jsbin.com</a>

This code works. We can get the calculated BMI when we move the slider. However, maybe you noticed, the labels for weight and height do not show what the slider is selecting. Instead, they just show e.g. `Weight ___kg`, which is useless since we do not know what value we are choosing for the weight.

The problem happens because when we map on `bmi$`, we do not have anymore the `weight` and `height` values. Therefore, for the function which renders the VTree, we need to use an Observable which emits a complete amount of data instead of just BMI data. We need a `state$` Observable.

{% highlight js %}
let state$ = Cycle.Rx.Observable.combineLatest(
  changeWeight$.startWith(70),
  changeHeight$.startWith(170),
  (weight, height) => {
    let heightMeters = height * 0.01;
    let bmi = Math.round(weight / (heightMeters * heightMeters));
    return {weight, height, bmi};
  }
);
{% endhighlight %}

Below is the program that uses `state$` to render all dynamic values correctly to the DOM.

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/dom';

function main({DOM}) {
  let changeWeight$ = DOM.get('#weight', 'input')
    .map(ev => ev.target.value);
  let changeHeight$ = DOM.get('#height', 'input')
    .map(ev => ev.target.value);
  let state$ = Cycle.Rx.Observable.combineLatest(
    changeWeight$.startWith(70),
    changeHeight$.startWith(170),
    (weight, height) => {
      let heightMeters = height * 0.01;
      let bmi = Math.round(weight / (heightMeters * heightMeters));
      return {weight, height, bmi};
    }
  );

  return {
    DOM: state$.map(({weight, height, bmi}) =>
      h('div', [
        h('div', [
          'Weight ' + weight + 'kg',
          h('input#weight', {type: 'range', min: 40, max: 140, value: weight})
        ]),
        h('div', [
          'Height ' + height + 'cm',
          h('input#height', {type: 'range', min: 140, max: 210, value: height})
        ]),
        h('h2', 'BMI is ' + bmi)
      ])
    )
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/vikaga/embed?output">JS Bin on jsbin.com</a>

Great, this program functions exactly like we want it to. Weight and height labels react to the sliders being dragged, and the BMI result gets recalculated as well.

*However*, we wrote all the code inside one function: `main()`. This approach doesn't scale, and even for a small app like this, it already looks too large and is doing too many things.

We need a proper architecture for user interfaces that follows the reactive, functional, and cyclic principles of Cycle.js. This is the subject of our [next chapter](/model-view-intent.html).

