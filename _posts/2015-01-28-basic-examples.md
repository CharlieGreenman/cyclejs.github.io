---
title:  "Basic examples"
tags: chapters
---

Cycle.js apps will always include at least three important components: `main()`, drivers, and `run()`. In `main()`, we listen to drivers (the input to `main`), and we speak to drivers (the output of `main`). In Haskell 1.0 jargon, `main()` takes driver "*response*" Observables and output driver "*request*" Observables. `Cycle.run()` ties `main()` and drivers together, as we saw in the last chapter.

{% highlight js %}
function main(driverResponses) {
  const driverRequests = {
    DOM: // transform driverResponses.DOM
         // through a series of RxJS operators
  };
  return driverRequests;
}

const drivers = {
  DOM: makeDOMDriver('#app')
};

Cycle.run(main, drivers);
{% endhighlight %}

In the case of the DOM Driver, our `main()` will interact with the user through the DOM. Most of our examples will use the DOM Driver, but keep in mind Cycle.js is modular and extensible. You could build an application, targetting native mobile for instance, without using the DOM Driver.

## Toggle a checkbox

Let's start from the assumption we have an `index.html` file with an element to contain our app.

{% highlight html %}
<!DOCTYPE html>
<html>
  <head>
    <script src="./checkbox-app.js"></script>
    <meta charset="utf-8">
    <title>Cycle.js checkbox</title>
  </head>
  <body>
    <div id="app"></div> <!-- Our container -->
  </body>
</html>
{% endhighlight %}

We will point our Cycle.js app to live inside `#app`. The `checkbox-app.js` file should look like this (before it is transpiled from ES6 to ES5, if that is required):

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main(responses) {
  const requests = {DOM: null};
  return requests;
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

Cycle *Web* is a package containing two drivers and some helpers to use those libraries. A DOM Driver is created with `makeDOMDriver()` and an HTML Driver (for server-side rendering) is created with `makeHTMLDriver()`. `CycleWeb` also includes `h()` and `svg()`, these are functions that output [`virtual-dom`](https://github.com/Matt-Esch/virtual-dom) virtual elements, usually called *VTree*.

Our `main()` for now does nothing. It takes driver `responses` and outputs driver `requests`. To make something appear on the screen, we need to output an Observable of VTree in `requests.DOM`. The name `DOM` in `requests` must match the name we gave in the drivers object given to `Cycle.run()`. This is how Cycle.js knows which drivers to match with witch request Observables. This is also true for responses: we listen to DOM events by using `responses.DOM`.

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main(responses) {
  const requests = {
    DOM: Cycle.Rx.Observable.just(false)
      .map(toggled =>
        h('div', [
          h('input', {type: 'checkbox'}), 'Toggle me',
          h('p', toggled ? 'ON' : 'off')
        ])
      )
  };
  return requests;
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/qekuni/embed?output">JS Bin on jsbin.com</a>

We just added an Observable of a `false` mapped to a VTree. [`Observable.just(x)`](http://reactivex.io/documentation/operators/just.html) creates a simple Observable which simply emits `x` once, then we used [`map()`](http://reactivex.io/documentation/operators/map.html) to convert that to the `virtual-dom` VTree containing an `<input type="checkbox">` and a `<p>` element displaying `off` if the `toggled` boolean was `false`, and displaying `ON` otherwise.

This is nice: we can see the DOM elements generated by the `virtual-dom` elements created with `h()`. But if we click the "Toggle me" checkbox, the label "off" under it does not change to "ON". That is because we are not listening to DOM events. In essence, our `main()` isn't listening to the *user*. We do that by using `responses.DOM`:

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main(responses) {
  const requests = {
    DOM: responses.DOM.get('input', 'change') // <-- !
      .map(ev => ev.target.checked) // <-- !
      .startWith(false) // <-- !
      .map(toggled =>
        h('div', [
          h('input', {type: 'checkbox'}), 'Toggle me',
          h('p', toggled ? 'ON' : 'off')
        ])
      )
  };
  return requests;
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/zewune/embed?output">JS Bin on jsbin.com</a>

Notice the lines we changed, with `<-- !`. We now map `change` events on the checkbox to the `checked` value of the element (the first `map()`) to VTrees displaying that value. However, we need a [`.startWith()`](http://reactivex.io/documentation/operators/startwith.html) to give a default value to be converted to a VTree. Without this, nothing would be shown! Why? Because our `requests` is reacting to `responses`, but `responses` is reacting to `requests`. If no one triggers the first event, nothing will happen. It is the same effect as meeting a stranger, and not having anything to say. Someone needs to take the initiative to start the conversation. That is what `main()` doing: kickstarting the interaction, and then letting subsequent actions be mutual reactions between `main()` and the DOM Driver.

## Increment and decrement a counter

We saw how to use the *dialogue* pattern of building user interfaces, but our case didn't have state: the label just reacted to the checkbox event. Normally applications have state in memory, so let's see how to build a Cycle.js for app that case.

If we have a counter Observable (emitting events to tell the current counter value), displaying the counter is as simple as this:

{% highlight js %}
count$.map(count =>
  h('div', [
    h('button.increment', 'Increment'),
    h('button.decrement', 'Decrement'),
    h('p', 'Clicked ' + count + ' times')
  ])    
)
{% endhighlight %}

> #### What does the suffixed dollar sign `$` mean?
>
> Notice we used the name `count$` for the Observable of current counter values. The dollar sign `$` *suffixed* to a name is a soft convention to indicate that the variable is an Observable (instance of an RxJS Observable). It is a naming helper to indicate types.
>
> Suppose you have an Observable of VTree depending on an Observable of "name" string
> {% highlight js %} var vtree$ = name$.map(name => h('h1', name)); {% endhighlight %}
>
> Notice that the function inside `map` takes `name` as argument, while the Observable is named `name$`. The naming convention indicates that `name` is the value being emitted by `name$`. In general, `foobar$` emits `foobar`. Without this convention, if `name$` would be named simply `name`, it would confuse readers about the types involved. Also, `name$` is succinct compared to alternatives like `nameObservable`, `nameStream`, or `nameObs`. This convention can also be extended to arrays: use plurality to indicate the type is an array. Example: `vtrees` is an array of `vtree`, but `vtree$` is an Observable of `vtree`.

But how to create `count$`? Clearly it must depend on increment clicks and decrement clicks. The former should mean a "+1" operation, and the latter a "-1" operation.

{% highlight js %}
let action$ = Cycle.Rx.Observable.merge(
  DOM.get('.decrement', 'click').map(ev => -1),
  DOM.get('.increment', 'click').map(ev => +1)
);
{% endhighlight %}

The [`merge`](http://reactivex.io/documentation/operators/merge.html) operator allows us to get an event stream of actions, either increment or decrement actions. In this sense, `merge` has *OR* semantics. But this still isn't `count$`, it is just `action$`.

`count$` should begin with zero, which justifies the use of a `startWith(0)` operator, but besides that we need a [`scan()`](http://reactivex.io/documentation/operators/scan.html) as well:

{% highlight js %}
let count$ = action$.startWith(0).scan((x,y) => x+y);
{% endhighlight %}

What does `scan` do? It is similar to [`reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) for Array, allowing us to accumulate values over the sequence. In functional programming languages, it is often called "fold". For instance, in [Elm](http://elm-lang.org/), [`foldp`](http://package.elm-lang.org/packages/elm-lang/core/2.1.0/Signal#foldp) is equivalent to `scan`. The name "*foldp*" indicates we are "folding the sequence from the *past*".

<p>
  {% include img/scan-counter.svg %}
</p>

If we put `action$` and `count$` together in our `main()`, we can implement the counter like this:

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main({DOM}) {
  let action$ = Cycle.Rx.Observable.merge(
    DOM.get('.decrement', 'click').map(ev => -1),
    DOM.get('.increment', 'click').map(ev => +1)
  );
  let count$ = action$.startWith(0).scan((x,y) => x+y);
  return {
    DOM: count$.map(count =>
        h('div', [
          h('button.decrement', 'Decrement'),
          h('button.increment', 'Increment'),
          h('p', 'Clicked ' + count + ' times')
        ])    
      )
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/hodaka/embed?output">JS Bin on jsbin.com</a>

## Body mass index calculator

Now that we got the hang of Cycle.js apps with state, let's tackle something a bit larger. Consider the following [BMI](https://en.wikipedia.org/wiki/Body_mass_index) calculator: it has a slider to select the weight, a slider to select the height, and a text indicates the calculated BMI from those weight and height values selected.

<a class="jsbin-embed" href="http://jsbin.com/yatexu/embed?output">JS Bin on jsbin.com</a>

In the previous example, we had the actions *decrement* and *increment*. In this example, we have "change weight" and "change height". These seem straight-forward to implement.

{% highlight js %}
let changeWeight$ = DOM.get('#weight', 'input')
  .map(ev => ev.target.value);
let changeHeight$ = DOM.get('#height', 'input')
  .map(ev => ev.target.value);
{% endhighlight %}

To combine these two actions and use their values to compute the BMI, we use the RxJS [`combineLatest`](http://reactivex.io/documentation/operators/combinelatest.html) operator. We saw in the previous example that `merge` had *OR* semantics. `combineLatest` has, on the other hand, *AND* semantics. For instance, to compute the BMI, we need a `weight` value *and* and a `height` value.

{% highlight js %}
let bmi$ = Cycle.Rx.Observable.combineLatest(
  changeWeight$.startWith(70),
  changeHeight$.startWith(170),
  (weight, height) => {
    const heightMeters = height * 0.01;
    return weight / (heightMeters * heightMeters);
  }
);
{% endhighlight %}

Now we just need a function to visualize the BMI result and the sliders. We do that by mapping `bmi$` to an Observable of VTree, and giving that to the `DOM` driver.

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main({DOM}) {
  let changeWeight$ = DOM.get('#weight', 'input')
    .map(ev => ev.target.value);
  let changeHeight$ = DOM.get('#height', 'input')
    .map(ev => ev.target.value);
  let bmi$ = Cycle.Rx.Observable.combineLatest(
    changeWeight$.startWith(70),
    changeHeight$.startWith(170),
    (weight, height) => {
      const heightMeters = height * 0.01;
      return Math.round(weight / (heightMeters * heightMeters));
    }
  );

  return {
    DOM: bmi$.map(bmi =>
      h('div', [
        h('div', [
          'Weight ___kg',
          h('input#weight', {type: 'range', min: 40, max: 140})
        ]),
        h('div', [
          'Height ___cm',
          h('input#height', {type: 'range', min: 140, max: 210})
        ]),
        h('h2', 'BMI is ' + bmi)
      ])
    )
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/yatexu/embed?output">JS Bin on jsbin.com</a>

This code works, we can get the calculated BMI when we move the slider. However, if you have noticed, the labels for weight and height do not show what the slider is selecting. Instead, they just show e.g. `Weight ___kg`, which is useless since we do not know what value we are choosing for the weight.

The problem happens because when we map on `bmi$`, we do not have anymore the `weight` and `height` values. Therefore, for the function which renders the VTree, we need to use an Observable which emits a complete amount of data instead of just BMI data. We need a `state$` Observable.

{% highlight js %}
let state$ = Cycle.Rx.Observable.combineLatest(
  changeWeight$.startWith(70),
  changeHeight$.startWith(170),
  (weight, height) => {
    const heightMeters = height * 0.01;
    const bmi = Math.round(weight / (heightMeters * heightMeters));
    return {weight, height, bmi};
  }
);
{% endhighlight %}

Below is the program that uses `state$` to render all dynamic values correctly to the DOM.

{% highlight js %}
import Cycle from '@cycle/core';
import {h, makeDOMDriver} from '@cycle/web';

function main({DOM}) {
  let changeWeight$ = DOM.get('#weight', 'input')
    .map(ev => ev.target.value);
  let changeHeight$ = DOM.get('#height', 'input')
    .map(ev => ev.target.value);
  let state$ = Cycle.Rx.Observable.combineLatest(
    changeWeight$.startWith(70),
    changeHeight$.startWith(170),
    (weight, height) => {
      const heightMeters = height * 0.01;
      const bmi = Math.round(weight / (heightMeters * heightMeters));
      return {weight, height, bmi};
    }
  );

  return {
    DOM: state$.map(({weight, height, bmi}) =>
      h('div', [
        h('div', [
          'Weight ' + weight + 'kg',
          h('input#weight', {type: 'range', min: 40, max: 140, value: weight})
        ]),
        h('div', [
          'Height ' + height + 'cm',
          h('input#height', {type: 'range', min: 140, max: 210, value: height})
        ]),
        h('h2', 'BMI is ' + bmi)
      ])
    )
  };
}

Cycle.run(main, {
  DOM: makeDOMDriver('#app')
});
{% endhighlight %}

<a class="jsbin-embed" href="http://jsbin.com/qegebu/embed?output">JS Bin on jsbin.com</a>

Great, this program functions exactly like we want it to. Weight and height labels react to the sliders being dragged, and the BMI result gets recalculated as well.

*However*, we wrote all code inside one function: `main()`. This approach doesn't scale, and even for a small sized app like this, it already looks too large, doing too many things.

We need a proper architecture for user interfaces that follows the reactive, functional, and cyclic principles of Cycle.js. That is the subject of our [next chapter](/model-view-intent.html).

