---
title: "Drivers"
tags: chapters
---

Throughout this documentation site we have extensively used *drivers*. The DOM Driver has been the most common one, but also `props` and `events` drivers for custom elements were used.

What are drivers? When should you use drivers? When should you create your own driver? How do drivers work? These are a few questions we will address in this chapter.

**Drivers are side-effectful functions with Observables as input (for reading from the external world) and Observables as output (for writing side effects).** They are meant for two purposes: as proxies to the user, and to isolate side effects from the app. Let's see how to use drivers as proxies to the user by studying the DOM Driver.

> <h4 id="why-the-name-driver">Why the name "driver"?</h4>
>
> In Haskell 1.0 Stream I/O, similar in nature to Cycle.js, there is a cyclic interaction between the program's `main` function and Haskell's `os` function. In operating systems, drivers are software interfaces to use some hardware devices, which incur side effects in the external world.
>
> In Cycle.js, one can consider the "operating system" to be the execution environment surrounding your application. Roughly speaking, the DOM, the console, JavaScript and JS APIs assume the role of the operating system for the web. We need *software adapters* to interface with the browser and other environments such as Node.js. Cycle.js drivers are there as adapters between the external world (including the user and the JavaScript execution environment) and the application world built with Cycle.js tools.

<h2 id="dom-driver">DOM Driver</h2>

The DOM Driver is the most important and most common driver in Cycle.js. When building interactive web apps, it is probably the most important tool in Cycle.js. In fact, while Cycle *Core* is only about 100 lines of code, Cycle *DOM* is at least 5 times larger.

It's main purpose is to be a proxy to the user using the browser. Conceptually we would like to work assuming the existence of a `human()` function, as this diagram reminds us:

<p>
  {% include /img/human-computer-diagram.svg %}
</p>

However, in practice, we write our `main()` function targeted at a `domDriver()`. For a user interacting with a browser, we only need to make our `main()` interact with the DOM. Whenever we need to show something to the user, we instead show that to the DOM, and the DOM together with the browser shows that to our user. When we need to detect the user's interaction events, we attach event listeners on the DOM, and the DOM will notify us when the user interacts with the browser on the computer.

<p>
  {% include /img/main-domdriver-side-effects.svg %}
</p>

Notice there are two directions of interaction with the external world through the DOM. The *write* effect is the renderization of our `virtual-dom` VTrees to DOM elements which can be shown on the user's screen. The *read* effect is the detection of DOM events generated by the user manipulating the computer.

The `domDriver()` manages these two effects while allowing them to be interfaced with the `main()`. The *input* to `domDriver()` captures instructions for the *write* effect, and the *read* effect is exposed as the *output* of `domDriver()`. The anatomy of the `domDriver()` function is roughly the following:

{% highlight js %}
function domDriver(vtree$) {
  // Use vtree$ as instructions to create DOM elements
  // ...
  return {
    select: function select(selector) {
      // returns an object with two fields: `observable`
      // and `events()`. The former, `observable`, is the
      // Observable of DOM elements matching the given
      // `selector`. Function `events(eventType)` returns
      // the Observable of `eventType` DOM events happening
      // on the elements matched by `selector`.
    }
  };
}
{% endhighlight %}

The input `vtree$` is the output from `main()`, and the output of `domDriver()` is the input to `main()`:

{% highlight js %}
function main({DOM}) {
  // Use DOM.select(selector).events(eventType)
  // ...
  // Create vtree$ somehow
  // ...
  return {
    DOM: vtree$
  };
}
{% endhighlight %}

<h2 id="isolating-side-effects">Isolating side effects</h2>

Drivers should always be associated with some side effect. As we saw, even though the DOM Driver's main purpose is to represent the user, it has write and read effects.

Nothing stops you as an app developer to write your `main()` function with side effects. A simple `console.log()` is already a side effect. For important side effects, though, it is beneficial to isolate them in a driver.

Imagine, for instance, a driver for network requests. By isolating the network request side effect, your application's `main()` function can focus on business logic related to the app's behavior, and not on lower-level instructions to interface with external resources. This also allows a simple method for testing network requests: you can replace the actual network driver with a fake network driver. It just needs to be a function that mimics the network driver function, and makes assertions.

Avoid making drivers if they do not have effects to the external world somehow. Especially do not create drivers to contain business logic. This is most likely a code smell. Drivers should focus solely on being an interface for effects, and usually are libraries that simply enable your Cycle.js app to perform different effects.

<h2 id="sink-and-source-drivers">Sink and source drivers</h2>

Most drivers, like the DOM Driver, have an *input* (to describe a *write*) and an *output* (to catch *reads*). However, we might have valid cases for write-only drivers and read-only drivers.

We have already seen some of these, when building custom elements. We could only read from `props`, and we could only produce/write `events`.

<p>
  {% include /img/custom-element-drivers.svg %}
</p>

{% highlight js %}
function customElem({props, DOM}) {
  // Read properties from props.get(propName)
  // Read DOM events from DOM.select(selector).events(eventType)
  // ...
  return {
    DOM: vtree$, // Write to the DOM
    events: { // Write/produce custom DOM events
      myEventType: // ...
    }
  };
}
{% endhighlight %}

`props` is said to be a **source** driver, and `events` is a **sink** driver. They enable the custom element to interact with its parent Cycle.js app.

Most drivers should have inputs and outputs, but others are by nature a sink or a source. For instance, if you want to isolate `console.log()` effects, you could create a `consoleDriver()` which must be a *sink* driver, because it only makes sense to write to the console, not read from it.

<h2 id="how-to-make-drivers">How to make drivers</h2>

You should only be reading this section if you have clear intentions to make a driver and expose it as a library. Typically, when writing a Cycle.js app, you do not need to create your drivers.

Consider first carefully which side effects your driver is responsible for. Is it source or a sink? Or can it have both read and write effects?

Once you map out the read/write effects, consider how diverse those can be. Create an empathic API which covers the common cases elegantly.

The **input** to the driver function is expected to be a single Observable. This is a practical API for the app developer to use when returning the `request` object in `main()`. Notice how the DOM Driver takes a single `vtree$` Observable as input, and how sophisticated and expressive VTrees from `virtual-dom` can be. On the other hand, don't always choose JavaScript objects as the values emitted in the Observable. Use objects when they make sense, and remember to keep the API simple rather than overly-generic. Don't over-engineer.

As a second, optional, argument to the driver function, you can expect `driverName`. This is used for those cases your driver function needs to know what name it was given when registered through the `drivers` object in `Cycle.run()`. Hence the driver function signature is:

{% highlight js %}
function myDriver(input$, driverName /* optional */)
{% endhighlight %}

The **output** of the driver function can either be a single Observable or a queryable collection of Observables.

In the case of a single Observable as output, depending on how diverse the values emitted by this Observable are, you might want to make those values easily filterable (using the RxJS `filter()` operator). Design an API which makes it easy to filter the Observable, keeping in mind what was provided as the input Observable to the driver function.

In some cases it is necessary to output a queryable collection of Observables, instead of a single one. A **queryable collection of Observables** is essentially a JavaScript object with a function used to choose a particular Observable based on a parameter, e.g. `get(param)`.

The DOM Driver, for instance, outputs a queryable collection of Observables. The collection is in fact lazy: none of the Observables outputted by `select(selector).events(eventType)` existed prior to the call of `events()`. This is because we cannot afford creating Observables for *all* possible events on *all* elements on the DOM. Take inspiration from the lazy queryable collection of Observables from the DOM Driver whenever your driver output contains a large (possibly infinite) amount of Observables.

<h2 id="example-driver-implementation">Example driver implementation</h2>

Suppose you have a fake real-time channel API called `Sock`. It is able to connect to a remote peer, send messages, and receive push-based messages. The API for `Sock` is:

{% highlight js %}
// Establish a connection to the peer
let sock = new Sock('unique-identifier-of-the-peer');

// Subscribe to messages received from the peer
sock.onReceive(function (msg) {
  console.log('Received message: ' + msg);
});

// Send a single message to the peer
sock.send('Hello world');
{% endhighlight %}

**How do we build a driver for `Sock`?** We start by identifying the effects. The *write* effect is `sock.send(msg)` and the *read* effect is the listener for received messages. Our `sockDriver(input)` should take `input` as instructions to perform the `send(msg)`. The output from `sockDriver()` should contain all received messages.

Since both input and output should be Observables, it's easy to see `input` in `sockDriver(input)` should be an Observable of outgoing messages to the peer. And conversely, the output should be an Observable of incoming messages. This is a draft of our driver function:

{% highlight js %}
function sockDriver(outgoing$) {
  outgoing$.subscribe(outgoing => sock.send(outgoing));
  return Rx.Observable.fromCallback(sock.onReceive)();
}
{% endhighlight %}

The subscription on `outgoing$` performs the `send()` side effect, and the Observable returned based on `sock.onReceive` takes data from the external world. However, `sockDriver` is assuming `sock` to be available in the closure. As we saw, `sock` needs to be created with a constructor `new Sock()`. To solve this dependency, we need to create a factory that makes `sockDriver()` functions.

{% highlight js %}
function makeSockDriver(peerId) {
  let sock = new Sock(peerId);
  return function sockDriver(outgoing$) {
    outgoing$.subscribe(outgoing => sock.send(outgoing));
    return Rx.Observable.fromCallback(sock.onReceive)();
  };
}
{% endhighlight %}

`makeSockDriver(peerId)` creates the `sock` instance, and returns the `sockDriver()` function. We use this in a Cycle.js app as such:

{% highlight js %}
function main({sock}) {
  let incoming$ = sock;
  // Create outgoing$ (Observable of string messages)
  // ...
  return {
    sock: outgoing$
  }
}

Cycle.run(main, {
  'sock': makeSockDriver('B23A79D5-some-unique-id-F2930')
});
{% endhighlight %}

Notice we have the `peerId` specified when the driver is created in `makeSockDriver(peerId)`. If the `main()` needs to dynamically connect to different peers according to some logic, then we shouldn't use this API anymore. Instead, we need the driver function to take instructions as input, such as "connect to peerId", or "send message to peerId". This is one example of the considerations you should take when designing a driver API.

<h2 id="drivers-make-cyclejs-extensible">Drivers make Cycle.js extensible</h2>

Cycle *Core* is a very small framework, and Cycle *DOM*'s Driver is available as an optional plugin for your app. This means it is simple to replace the DOM Driver with any other driver function providing interaction with the user.

You can for instance fork the DOM Driver, adapt it to your preferences, and use it in a Cycle.js app. You can create a driver to interface with sockets. Drivers to perform network requests. Drivers meant for Node.js. Drivers that target other UI trees, such as `<canvas>` or even native mobile UI.

As a framework, it cannot be compared to monoliths which have ruled web development in the recent years. Cycle.js itself is after all just a small tool and a convention to create reactive dialogues with the external world using RxJS Observables.
